
1、禁止滚动条
    html,body{
        height:100%;
        overflow:hidden;
        //上面会禁止全部的滚动条    下面的可以有一个滚动条（可以自己选择方向）
        overflow-y：auto；
    }

2、 undefined 报错：
            如 a.b
        如果是报错误undefined，就代表a为undefined。
        如果是consoe.log打印出来a.b  undefined 那么是b不存在。

3、 meta属性：
        在路由组件中 可以有meta属性  （this.$route.meta）， 在注册路由配置的文件中可以进行添加
           属性值。  如；    routes：[{path:'/a',component:A, meta:{isShowFooter:true}]
           进行控制公共组件底部导航的显示与隐藏。   还可以应用于其他地方。

4、 template 中的数据引用：
        1、在template中使用data中的数据，v-bind：设置成动态或者{{ }}可以直接使用。
        2、在script的mounted或者methods中 this.xxx 使用或者更改数据状态。

        3、template中遍历的数据，在script中使用可以定义事件方法，传入参数使用。
            如：@click="goto(数据)"。

5、better-scroll库的问题：
            1、需要在页面和数据全部加载完毕后在进行实例化。（可以利用this.$nexttick()方法结绝
                    或者利用this.dispatch返回的是promise对象来解决。）
            2、better-scroll 库会禁止原生事件的触发，如果想使用，需要进行配置相应的事件为true。

6、子路由。
         路由注册：  routes{path:'/home',component:Home}
         子路由注册：routes{path:'/home',
                            component:Home,
                            redirect:'/home/home2',         //重定向的路径
                            children:[{ path:'/home/home2',component:'/'}]}


7、跨域问题处理“
    在脚手架3中创建vue.config.js 配置一下代码解决跨域问题。
    在脚手架中 config /index.js中配置。

        module.exports = {
            // 代理配置
            devServer: {
                proxy: {
                    '/api': {
                        target: 'http://m.you.163.com',
                        changeOrigin: true,
                        pathRewrite: {
                            '^/api': '', // 去掉path前面的/api
                        },
                    }
                }
            }
        }

8、函数节流
        阻止一个函数在很短的而时间内连续调用多次。（节省资源，提高性能）
        应用场景：（1）浏览器滚动事件scroll

               (2)  鼠标的点击事件 mouseup, mousedown,mousemove

               (3)  键盘的keyup, keydown， input事件

                （4）window的resize事件

        （如下面利用清除定时器方式，阻止在200毫秒内频繁触发函数，多次频繁请求会清除上一个定时器
        只有间隔时间200ms才能触发函数。）
        clearTimeout(timeId);
        timeId = setTimeout(()=>{
            执行的函数代码。
        },200)


 函数节流改进版本：
        实际上我们希望时间间隔内虽然不频繁调用，但是一定要执行一次函数，所以有改进版本：
        （利用时间戳记录第一次的时间，然后记录点击时的时间是否大于设置的间隔时间。）
        clearTimeout(timeId);       //先清除定时器
        let curt = Date.now()      //获取当前的时间
        if(！obj.start){             // 如果这个函数第一次使用，则设置为当前时间
            obj.start = curt
        }
        if(curt-obj.start > musttime){     //判断当前时间-开始触发的时间是否大于设置的间隔时间
            执行得函数                               //大于就执行一次函数
            obj.start = curt                    //然后把当前时间赋值给初始时间。
        }else{                               //不大于就创建一个新得定时器。
             timeId = setTimeout(()=>{
                        执行的函数代码。
            },musttime)
        }



正则表达式：
        test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。

        手机号验证：/^1[3456789]\d{9}$/    ^1以1开头  [3456789]第二位3-9得数字任意一个  \d{9}  [0-9]得数字九位
            加起来共十一位。  或者使用：/^1(3|4|5|6|7|8|9)\d{9}$/
              // ：整体符号，^ 以什么开头  []匹配其中得一个  （）代表整体，匹配其中得一个使用 或 |   \d 0-9数字 {9}位数
                $ 以什么结束  +至少有一个或者多个 ，*0个或者多个  {2，3}两个或者三个


input触发的事件：
            onBlur   失去焦点时进行触发。
            oninput   值发生改变时会时时触发。


获取几个得数据有多种需要穿插着不同的样式进行显示：
        1、每个数据得样式写出来一个，
        2、v-for遍历数据遍历标签，利用数据里面得style或者type等进行判断以显示匹配当前数据得组件
        3、因为数据有两层结构，所以使用双层循环。
上拉加载更多数据：
        1、利用better-scrollku进行滑动
        2、然后绑定better库得事件 pullingUp,当下拉到底部得时候会自动触发事件
        3、触发事件 得时候根据接口文档发送请求
        4、将加载来得数据拼接到现在数据得里面  （因为要添加每一项得数据，所以用foreach遍历新数据，把每一项push进老数据中)
        5、也可以将数据进行watch监视，或者当作computed计算属性，然后遍历即可。






  未完成 ：分类组件通信，  正则验证。   首页私人定制

